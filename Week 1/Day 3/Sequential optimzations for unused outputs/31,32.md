# 🧮 Synthesis and RTL Coding - Optimisation Techniques

This chapter explores **unused output optimisation** during synthesis, showing how synthesis tools remove logic that does not affect the module’s primary outputs.  
We study examples of sequential counters in Verilog to see how synthesis minimises hardware.

---

## 📖 1.1 Introduction to Unused Output Optimisation

- **Definition**: During synthesis, any logic not contributing to primary outputs is eliminated.  
- **Core Principle**:  
  - Registers or gates unused by outputs are **optimised away**.  
  - Logic feeding unused components is also removed.  
- **Goal**: Achieve smaller, more efficient hardware by removing redundancy.  

---

## 🔢 1.2 Case Study 1: `counter_opt.v` – Unused Outputs

### 1.2.1 RTL Code Analysis
- Design: 3-bit synchronous up-counter with clock & reset.  
- Behaviour:  
  - On reset → counter resets to `0`.  
  - On each rising clock edge → counter increments (`0 → 7 → 0`).  
- Output: **Only the least significant bit (LSB)** of `count` is connected to Q.  
assign Q = count;
- Observation:  
- `count[1]` and `count[2]` are generated but unused.  
- These signals have **no functional role** in determining Q.  

### 1.2.2 Synthesis Result & Analysis
- **Expectation**: A 3-bit counter → 3 DFFs.  
- **Actual Result**: Only **1 DFF inferred**, not 3.  
- **Reason**:  
- Unused bits `count[1]` and `count[2]` were **optimised away**.  
- The incrementer logic generating them was also removed.  
- **Simplified Behaviour**:  
- Since only `count[0]` was used, synthesis recognised it is just a **toggle flop** (toggling every clock cycle).  
- Implemented as **1 flip-flop + 1 inverter** (Q fed back inverted to D).  

✅ **Conclusion**:  
Unused counter bits were fully eliminated → final hardware = **1 FF + inverter**, instead of a 3-bit counter.

---

## 🔁 1.3 Case Study 2: `counter_opt2.v` – All Outputs Used

### 1.3.1 Modified RTL Code
- Change: Output Q depends on **all three counter bits**.  
assign Q = (count == 3'b100); // Detect when count = 4
- Implication: Now Q depends on `count[2:0]`.  
- The synthesis tool **must preserve all 3 flops** and incrementing logic.

### 1.3.2 Synthesis Result & Analysis
- **Result**: All **3 DFFs inferred** and present in netlist.  
- **Logic Structure**:  
- Incrementer logic (composed of ADD/NAND/NOR gates) is visible to implement count progression.  
- Logic for Q = (count == 4) synthesised into equivalent gate logic using NOR + inverters via **De Morgan’s theorem**.  

**Comparison with Case 1**:  
- Case 1 → unused bits optimised away.  
- Case 2 → all counter bits preserved since all influence final output.  

---

## ✅ 1.4 Key Takeaways

- **Context-aware**: Synthesis removes any logic not connected to primary outputs.  
- **Complete removal**: Optimisation cascades back through inputs → removing both the unused register and its logic cone.  
- **Efficiency**: Saves **area and power** in final design.  
- **Design Note**:  
- If internal signals are intended only for debugging, but not tied to outputs, they **will be removed**.  
- Use special `(* keep *)` or `dont_touch` synthesis attributes if they must be preserved.  

**Final Principle**:  
> “If logic has no direct role in determining primary outputs, it will be optimised away.”  

