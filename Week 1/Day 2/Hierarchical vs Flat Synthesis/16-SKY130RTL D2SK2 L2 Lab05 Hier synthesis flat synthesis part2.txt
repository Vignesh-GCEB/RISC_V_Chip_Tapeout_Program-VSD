Transcription
So here we see the hierarchies are preserved. Okay, now what I'm going to do, I'm going to do something called as flatten. Flatten is a command to write out a flat netlist. So now I'm going to do write very log multiple modules let's look at this netlist okay again i missed this no attr switch let me use that So here you see, there are no, okay, let me split open that for your reference here. So multiple modules higher dot V. So I'm showing you both the netlist here. See here, the hierarchies of submodule one and submodule two are preserved. Whereas here, we don't see them. It's a single netlist. I don't see all these hierarchies here. These hierarchies are flattened out. And I directly see the instantiation of AND gate and this OR gate, this is OR gate and this is AND gate. I directly see the instantiation of this AND gate and OR gate directly under the module called multiple modules. I don't see any more U1 and U2. Okay. This is the distinction between using the flat-end switch versus not using the flat-end switch. Okay. OK, I'm going to intentionally exit it because I want to read the design again. So now let's say, for example, given multiple modules. First, let me read the library. Given the multiple modules, let's say I want to synthesize a sub module level. Then what is the way to do it? okay anyway in the previous example i forgot to show you something else let me show that first my lab fill log file i'm sorry read very log multiple modules dot v so i'm going to say synth hyphen top multiple modules So this we have already seen, so I'm going to do the ABC-Liberty. Then I'm going to do a flatten. I'm going to do a show. I forgot to show you this last time. So now you see previously we saw when we did the show we saw U1 and U2 correct. We are not seeing U1 and U2 anymore because I flattened it. I am seeing AND gate and this is the inverter feeding the NAND gate. So this is the OR gate. So this is your U1 the output of U1 is feeding U2 with another input coming from C. This is what is your whole net based. This is what is your multiple module looking like ok. So when we flatten, we directly see the structure completely. Which we didn't see when we did this when we executed show before we saw U1 and U2. We are not seeing U1 and U2 anymore. We are seeing the underlying components within U1 and U2 completely written out flattened. OK, I will launch this again. So this time we will do a sub module level synthesis. And I'll also explain what is the need for doing the submodule level synthesis. I'm sorry. I missed the keyword. Read lib liberty minus lib, yes. Read verilog dot dot slash, no, multiple modules dot v. now we say synth-top now as we look at the design let me show you once again as we were looking at the design this is our design correct so if you look at this design here we have u2 we have u1 we don't want to synthesize multiple module we want to synthesize this at u1 level or u2 level say for example we'll see why we do that Subsequently, now I'm going to say synth-top. I'm going to say sub module 1. So I'm going to do a synthesis at sub module 1 level. Though I have read the RTL at top module level, I'm going to do the synthesize at sub module 2 level or sub module 1 level. So now you see it has inferred only one AND gate. It is not inferring the sub module 2 at all. It is just inferred sub module 1. So now I'm going to do show and let me link the design ABC-liberty. So now you're going to see only the AND gate you're seeing. You're not seeing submodule two, you're not seeing U1 or anything, correct? This is very important. So now you have created only the submodule one. So now why will you do this? Let's try to understand. We did, we control the module which we are synthesizing using the keyword synth-top, but let's see why we do this. So why? Why is it? Let's say, for example, your design looks something like this. This is your top module. And you have multiple instantiation of a same component. Let's say you have a design called, say, a multiplier. And your multiplier is instantiated so many times for whatsoever reason. I'll call this as mult one, mult two. MULT3, MULT4, MULT5, MULT6. There are six instantiation of multipliers. Now, instead of synthesizing the multiplier six times, you would like to synthesize it once and you will replicate it six times. This saves time, correct? You don't want to synthesize your multiplier six times. You synthesize it one time and you replicate that netlist six times and stitch it together in the top module. Correct? So, module level synthesis is preferred when we have multiple instances of same module or this is one reason okay this is not the only reason or second reason is we want to do divide and conquer approach okay let's say your design is very massive so this is used in massive designs let's say your design is very massive And let's say when you give this massive design to your tool, the tool is not doing a good job. So what you want to do instead of giving the entire massive design to the tool, you are giving one portion by one portion to the tool so that it writes out a very optimized and sweet netlist to you. And then you stitch all this netlist together at the top level to get the best possible netlist at the top level. So these are the Two reasons why we do a submodule level synthesis and we control which module you are going to synthesize by using the keyword synth-top. In YoSYS, the keyword is synth-top module name. This controls what module you are going to synthesize it. Okay, this brings us to the end of this lab. Thank you.