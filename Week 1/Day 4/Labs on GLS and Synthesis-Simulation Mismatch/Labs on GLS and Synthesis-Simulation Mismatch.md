# üß™ Fundamentals of Gate-Level Simulation (GLS)

This document introduces **Gate-Level Simulation (GLS)**, explains its workflow, and demonstrates **synthesis-simulation mismatches** through multiplexer case studies.

---

## üìñ Chapter 1: Fundamentals of Gate-Level Simulation

### 1.1 Introduction to GLS
- **Definition**: GLS simulates the design after synthesis, using the **gate-level netlist** of standard cells instead of the RTL code.  
- **Concept**: RTL Testbench is reused ‚Üí DUT swapped from RTL to the gate-level netlist.  
- **Benefit**: Validates the design as it will exist in hardware.

---

### 1.2 The GLS Workflow
To run GLS, we need three components:
1. **Netlist (.v)** ‚Äì synthesiser output describing interconnections of standard cells.  
2. **Standard Cell Models** ‚Äì Verilog models defining behaviour of cells like AND, OR, INV, DFF.  
3. **Testbench** ‚Äì same as RTL testbench (applies stimulus/checks outputs).  

**Simulation Flow:**
Netlist + Gate-Level Models + Testbench
‚Üí iVerilog Simulator
‚Üí VCD waveform (.vcd)
‚Üí GTKWave Viewer

---

### 1.3 Distinguishing GLS vs RTL Simulation
- **RTL Simulation**: Hierarchy in waveform shows only RTL modules/UUT.  
- **GLS**: Hierarchy shows instantiated **standard cells** (with autogenerated names like `_6_, _7_`).  

---

## üßÆ Chapter 2: Case Study 1 ‚Äî Standard 2-to-1 MUX

### 2.1 MUX Using Ternary Operator

assign y = select ? i1 : i0;
- If `select = 0` ‚Üí y = i0  
- If `select = 1` ‚Üí y = i1  

Efficient and synthesiser-friendly description.  

---

### 2.2 RTL Simulation
- ‚úÖ Waveform matches expected MUX behaviour.  
- `y` follows i0 when select=0, and i1 when select=1.  

---

### 2.3 Synthesis and Netlist Analysis
- Synthesiser infers a correct MUX.  
- Implemented using NANDs, inverters, AOI/OAI cells.  
- Derived Boolean Equation:  
\[
y = (\bar{select} \cdot i0) + (select \cdot i1)
\]  
This matches the exact MUX logic function.  

---

### 2.4 GLS Verification
- GLS waveform ‚âà RTL simulation.  
- ‚úÖ Confirms synthesis was correct ‚Üí no mismatches.  

---

## ‚ö†Ô∏è Chapter 3: Case Study 2 ‚Äî Synthesis-Simulation Mismatch

### 3.1 "Bad MUX" ‚Äî Incomplete Sensitivity List
**Flawed RTL Code:**

always @(select) begin
if (select) y = i1;
else y = i0;
end

- **Problem**: Sensitivity list only has `select`. Missing `i0` and `i1`.  

---

### 3.2 RTL Simulation ‚Äî Incorrect Behaviour
- Simulator triggers block **only on select changes**.  
- If i0/i1 toggle while select stable ‚Üí **y does not update**.  
- Appears like a **flop/latch** instead of a combinational mux.  

---

### 3.3 Synthesis ‚Äî Correct Behaviour
- Synthesis tool ignores sensitivity list.  
- Analyses `if-else` logic and infers a normal **MUX** circuit.  

---

### 3.4 GLS Waveform
- Correct GLS output:  
  - When select=0 ‚Üí y follows i0 immediately.  
  - When select=1 ‚Üí y follows i1 immediately.  
- ‚úÖ Matches actual intended hardware behaviour.  

---

### 3.5 Root Cause Analysis
- **Issue**: Simulation-synthesis mismatch due to missing signals in sensitivity list.  
- **Key Takeaway**:  
  - Always include **all inputs** used in combinational logic inside sensitivity list.  
  - Use safer construct in modern Verilog/SystemVerilog:  
    ```
    always @(*)
    ```

---

## ‚úÖ Final Takeaways
- **GLS validates post-synthesis design** behaviour using standard cell models.  
- Matches logical behaviour and can expose synthesis-simulation mismatches.  
- **Common pitfalls**:  
  - Incomplete sensitivity lists (use always @(*))  
  - Blocking (`=`) vs. Non-blocking (`<=`) issues (reviewed in related labs).  
- GLS is an essential step before timing-aware simulations and physical design.  

